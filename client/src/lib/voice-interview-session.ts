/**
 * Voice Interview Session System
 * 
 * Sessions are built from related questions that form a coherent topic.
 * Each session contains 4-6 questions that progress from basic to advanced.
 * 
 * Session Flow:
 * 1. User selects a session topic
 * 2. Questions are presented in order (easy â†’ hard)
 * 3. Each question expects a focused 1-2 sentence answer
 * 4. Immediate feedback with keyword matching
 * 5. Session summary with overall score
 */

import type { Question } from '../types';

// ============================================
// TYPES
// ============================================

export interface VoiceSession {
  id: string;
  topic: string;
  description: string;
  channel: string;
  difficulty: string;
  questionIds: string[];
  totalQuestions: number;
  estimatedMinutes: number;
}

export interface SessionQuestion {
  id: string;
  question: string;
  expectedKeywords: string[];      // Keywords from voiceKeywords
  acceptablePhrases: string[];     // Generated alternatives
  difficulty: string;
  order: number;
}

export interface SessionAnswer {
  questionId: string;
  userAnswer: string;
  score: number;                   // 0-100
  keywordsCovered: string[];
  keywordsMissed: string[];
  isCorrect: boolean;              // Score >= 60
  feedback: string;
}

export interface SessionResult {
  sessionId: string;
  topic: string;
  answers: SessionAnswer[];
  overallScore: number;
  verdict: 'excellent' | 'good' | 'needs-work' | 'review-topic';
  summary: string;
  strengths: string[];
  areasToImprove: string[];
  completedAt: string;
}

export interface SessionState {
  session: VoiceSession;
  questions: SessionQuestion[];
  currentQuestionIndex: number;
  answers: SessionAnswer[];
  startedAt: string;
  status: 'intro' | 'in-progress' | 'completed';
}

// ============================================
// SESSION LOADING
// ============================================

let cachedSessions: VoiceSession[] = [];

/**
 * Load pre-built voice sessions
 * Sessions are generated by the session-builder-bot and exported to JSON
 */
export async function loadVoiceSessions(): Promise<VoiceSession[]> {
  if (cachedSessions.length > 0) return cachedSessions;
  
  try {
    const response = await fetch('/data/voice-sessions.json');
    if (!response.ok) {
      console.warn('Voice sessions file not found, will generate from questions');
      return [];
    }
    
    const data = await response.json();
    cachedSessions = data.sessions || [];
    return cachedSessions;
  } catch (e) {
    console.error('Failed to load voice sessions:', e);
    return [];
  }
}

/**
 * Get sessions for a specific channel
 */
export async function getSessionsByChannel(channel: string): Promise<VoiceSession[]> {
  const sessions = await loadVoiceSessions();
  return sessions.filter(s => s.channel === channel);
}

/**
 * Build session questions from question data
 */
export function buildSessionQuestions(
  session: VoiceSession,
  questions: Question[]
): SessionQuestion[] {
  const sessionQuestions: SessionQuestion[] = [];
  
  for (let i = 0; i < session.questionIds.length; i++) {
    const questionId = session.questionIds[i];
    const question = questions.find(q => q.id === questionId);
    
    if (question) {
      const keywords = question.voiceKeywords || [];
      
      sessionQuestions.push({
        id: question.id,
        question: question.question,
        expectedKeywords: keywords,
        acceptablePhrases: generateAcceptablePhrases(keywords),
        difficulty: question.difficulty,
        order: i + 1
      });
    }
  }
  
  return sessionQuestions;
}

// ============================================
// ANSWER EVALUATION
// ============================================

/**
 * Evaluate a session question answer
 * Simple keyword-based evaluation for focused answers
 */
export function evaluateSessionAnswer(
  userAnswer: string,
  sessionQuestion: SessionQuestion
): SessionAnswer {
  const normalizedAnswer = userAnswer.toLowerCase().trim();
  const { expectedKeywords, acceptablePhrases } = sessionQuestion;
  
  const keywordsCovered: string[] = [];
  const keywordsMissed: string[] = [];
  
  // Check each expected keyword
  for (const keyword of expectedKeywords) {
    const keywordLower = keyword.toLowerCase();
    
    // Direct match
    if (normalizedAnswer.includes(keywordLower)) {
      keywordsCovered.push(keyword);
      continue;
    }
    
    // Check acceptable phrases
    const phraseMatch = acceptablePhrases.some(phrase => 
      normalizedAnswer.includes(phrase.toLowerCase())
    );
    
    if (phraseMatch) {
      keywordsCovered.push(keyword);
    } else {
      keywordsMissed.push(keyword);
    }
  }
  
  // Calculate score
  const keywordScore = expectedKeywords.length > 0 
    ? (keywordsCovered.length / expectedKeywords.length) * 100 
    : 50;
  
  // Bonus for additional relevant terms
  const bonusTerms = findBonusTerms(normalizedAnswer, expectedKeywords);
  const bonus = Math.min(bonusTerms.length * 5, 15);
  
  // Penalty for very short answers
  const wordCount = normalizedAnswer.split(/\s+/).length;
  const lengthPenalty = wordCount < 5 ? 20 : wordCount < 8 ? 10 : 0;
  
  const score = Math.min(100, Math.max(0, Math.round(keywordScore + bonus - lengthPenalty)));
  const isCorrect = score >= 60;
  
  // Generate feedback
  const feedback = generateFeedback(score, keywordsCovered, keywordsMissed);
  
  return {
    questionId: sessionQuestion.id,
    userAnswer,
    score,
    keywordsCovered,
    keywordsMissed,
    isCorrect,
    feedback
  };
}

function findBonusTerms(answer: string, expectedKeywords: string[]): string[] {
  // Technical terms that show deeper understanding
  const bonusTerms = [
    'scalability', 'availability', 'reliability', 'latency', 'throughput',
    'consistency', 'partition', 'replication', 'sharding', 'caching',
    'load balancer', 'microservices', 'distributed', 'fault tolerance',
    'monitoring', 'logging', 'alerting', 'sla', 'slo', 'sli',
    'kubernetes', 'docker', 'ci/cd', 'deployment', 'rollback'
  ];
  
  const found: string[] = [];
  const expectedLower = expectedKeywords.map(k => k.toLowerCase());
  
  for (const term of bonusTerms) {
    if (answer.includes(term) && !expectedLower.includes(term)) {
      found.push(term);
    }
  }
  
  return found;
}

function generateFeedback(
  score: number,
  covered: string[],
  missed: string[]
): string {
  if (score >= 80) {
    return "Excellent! You covered the key concepts well.";
  } else if (score >= 60) {
    if (missed.length > 0) {
      return `Good answer! Also consider: ${missed.slice(0, 2).join(', ')}.`;
    }
    return "Good answer with the main points covered.";
  } else if (score >= 40) {
    return `Partial answer. Key terms to include: ${missed.slice(0, 3).join(', ')}.`;
  } else {
    return `Review this topic. Focus on: ${missed.slice(0, 3).join(', ')}.`;
  }
}

function generateAcceptablePhrases(keywords: string[]): string[] {
  const phrases: string[] = [];
  
  const synonyms: Record<string, string[]> = {
    'kubernetes': ['k8s', 'kube', 'container orchestration'],
    'load balancer': ['lb', 'load balancing', 'traffic distribution'],
    'database': ['db', 'data store', 'datastore'],
    'availability': ['uptime', 'high availability', 'ha'],
    'latency': ['response time', 'delay', 'lag'],
    'throughput': ['bandwidth', 'capacity', 'requests per second'],
    'microservices': ['micro services', 'microservice', 'service-oriented'],
    'authentication': ['auth', 'authn', 'login'],
    'authorization': ['authz', 'permissions', 'access control'],
    'caching': ['cache', 'cached', 'in-memory'],
    'replication': ['replicate', 'replica', 'copies'],
    'sharding': ['shard', 'partitioning', 'horizontal partition'],
    'monitoring': ['monitor', 'observability', 'metrics'],
    'deployment': ['deploy', 'release', 'rollout'],
    'scalability': ['scale', 'scaling', 'scalable'],
    'consistency': ['consistent', 'data consistency'],
    'idempotency': ['idempotent', 'safe to retry'],
    'ci/cd': ['continuous integration', 'continuous deployment', 'pipeline']
  };
  
  for (const keyword of keywords) {
    const kw = keyword.toLowerCase();
    
    // Add synonyms
    if (synonyms[kw]) {
      phrases.push(...synonyms[kw]);
    }
    
    // Add plural/singular variations
    if (kw.endsWith('s') && kw.length > 3) {
      phrases.push(kw.slice(0, -1));
    } else if (!kw.endsWith('s')) {
      phrases.push(kw + 's');
    }
  }
  
  return Array.from(new Set(phrases));
}

// ============================================
// SESSION MANAGEMENT
// ============================================

/**
 * Start a new voice session
 */
export function startSession(
  session: VoiceSession,
  questions: SessionQuestion[]
): SessionState {
  return {
    session,
    questions,
    currentQuestionIndex: 0,
    answers: [],
    startedAt: new Date().toISOString(),
    status: 'intro'
  };
}

/**
 * Begin answering questions
 */
export function beginSession(state: SessionState): SessionState {
  return {
    ...state,
    status: 'in-progress'
  };
}

/**
 * Get current question
 */
export function getCurrentQuestion(state: SessionState): SessionQuestion | null {
  if (state.status === 'completed') return null;
  return state.questions[state.currentQuestionIndex] || null;
}

/**
 * Submit answer and move to next question or complete
 */
export function submitAnswer(
  state: SessionState,
  userAnswer: string
): SessionState {
  const currentQuestion = state.questions[state.currentQuestionIndex];
  if (!currentQuestion) return state;
  
  const evaluation = evaluateSessionAnswer(userAnswer, currentQuestion);
  const newAnswers = [...state.answers, evaluation];
  
  const isLastQuestion = state.currentQuestionIndex >= state.questions.length - 1;
  
  return {
    ...state,
    answers: newAnswers,
    status: isLastQuestion ? 'completed' : 'in-progress'
  };
}

/**
 * Move to next question
 */
export function nextQuestion(state: SessionState): SessionState {
  if (state.currentQuestionIndex >= state.questions.length - 1) {
    return { ...state, status: 'completed' };
  }
  
  return {
    ...state,
    currentQuestionIndex: state.currentQuestionIndex + 1
  };
}

/**
 * Calculate final session results
 */
export function completeSession(state: SessionState): SessionResult {
  const { session, answers } = state;
  
  // Calculate overall score
  const totalScore = answers.reduce((sum, a) => sum + a.score, 0);
  const overallScore = answers.length > 0 ? Math.round(totalScore / answers.length) : 0;
  
  // Determine verdict
  let verdict: SessionResult['verdict'];
  if (overallScore >= 80) verdict = 'excellent';
  else if (overallScore >= 60) verdict = 'good';
  else if (overallScore >= 40) verdict = 'needs-work';
  else verdict = 'review-topic';
  
  // Collect missed keywords
  const allMissed = answers.flatMap(a => a.keywordsMissed);
  const uniqueMissed = Array.from(new Set(allMissed));
  
  // Collect covered keywords
  const allCovered = answers.flatMap(a => a.keywordsCovered);
  const uniqueCovered = Array.from(new Set(allCovered));
  
  // Generate strengths
  const strengths: string[] = [];
  const correctCount = answers.filter(a => a.isCorrect).length;
  
  if (correctCount === answers.length) {
    strengths.push("Perfect score - all questions answered correctly!");
  } else if (correctCount >= answers.length * 0.7) {
    strengths.push(`Strong performance: ${correctCount}/${answers.length} correct`);
  }
  
  if (uniqueCovered.length >= 5) {
    strengths.push(`Good keyword coverage: ${uniqueCovered.slice(0, 4).join(', ')}`);
  }
  
  // Generate areas to improve
  const areasToImprove: string[] = [];
  
  if (uniqueMissed.length > 0) {
    areasToImprove.push(`Review: ${uniqueMissed.slice(0, 5).join(', ')}`);
  }
  
  const lowScoreCount = answers.filter(a => a.score < 50).length;
  if (lowScoreCount > 0) {
    areasToImprove.push(`${lowScoreCount} question(s) need more practice`);
  }
  
  // Generate summary
  const summary = generateSessionSummary(overallScore, correctCount, answers.length, session.topic);
  
  return {
    sessionId: session.id,
    topic: session.topic,
    answers,
    overallScore,
    verdict,
    summary,
    strengths,
    areasToImprove,
    completedAt: new Date().toISOString()
  };
}

function generateSessionSummary(
  score: number,
  correct: number,
  total: number,
  topic: string
): string {
  if (score >= 80) {
    return `Excellent understanding of ${topic}! You answered ${correct}/${total} questions correctly.`;
  } else if (score >= 60) {
    return `Good grasp of ${topic}. ${correct}/${total} correct. Keep practicing!`;
  } else if (score >= 40) {
    return `Basic understanding of ${topic} (${correct}/${total}). Review the missed concepts.`;
  } else {
    return `${topic} needs more study. Score: ${correct}/${total}. Review fundamentals.`;
  }
}

// ============================================
// FALLBACK: GENERATE SESSIONS FROM QUESTIONS
// ============================================

/**
 * Generate sessions from questions when pre-built sessions aren't available
 * Groups questions by subChannel and creates coherent sessions
 */
export function generateSessionsFromQuestions(questions: Question[]): VoiceSession[] {
  const sessions: VoiceSession[] = [];
  
  // Filter voice-suitable questions
  const suitable = questions.filter(q => 
    q.voiceSuitable === true && 
    q.voiceKeywords && 
    q.voiceKeywords.length >= 3
  );
  
  // Group by channel + subChannel
  const groups: Record<string, Question[]> = {};
  
  for (const q of suitable) {
    const key = `${q.channel}:${q.subChannel}`;
    if (!groups[key]) groups[key] = [];
    groups[key].push(q);
  }
  
  // Create sessions from groups with 4+ questions
  for (const [key, groupQuestions] of Object.entries(groups)) {
    if (groupQuestions.length < 4) continue;
    
    const [channel, subChannel] = key.split(':');
    
    // Sort by difficulty
    const sorted = groupQuestions.sort((a, b) => {
      const order: Record<string, number> = { beginner: 0, intermediate: 1, advanced: 2 };
      return (order[a.difficulty] || 1) - (order[b.difficulty] || 1);
    });
    
    // Take 4-6 questions
    const sessionQuestions = sorted.slice(0, 6);
    
    // Determine overall difficulty
    const difficulties = sessionQuestions.map(q => q.difficulty);
    const difficulty = difficulties.includes('advanced') ? 'advanced' :
                      difficulties.includes('intermediate') ? 'intermediate' : 'beginner';
    
    sessions.push({
      id: `gen-${channel}-${subChannel}-${Date.now()}`,
      topic: formatTopic(subChannel),
      description: `Practice session covering ${subChannel} concepts`,
      channel,
      difficulty,
      questionIds: sessionQuestions.map(q => q.id),
      totalQuestions: sessionQuestions.length,
      estimatedMinutes: sessionQuestions.length * 2
    });
  }
  
  return sessions;
}

function formatTopic(subChannel: string): string {
  return subChannel
    .replace(/-/g, ' ')
    .replace(/\b\w/g, c => c.toUpperCase());
}

// ============================================
// STORAGE HELPERS
// ============================================

const SESSION_STATE_KEY = 'voice-session-state';
const SESSION_HISTORY_KEY = 'voice-session-history';

export function saveSessionState(state: SessionState): void {
  try {
    localStorage.setItem(SESSION_STATE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error('Failed to save session state:', e);
  }
}

export function loadSessionState(): SessionState | null {
  try {
    const saved = localStorage.getItem(SESSION_STATE_KEY);
    return saved ? JSON.parse(saved) : null;
  } catch (e) {
    console.error('Failed to load session state:', e);
    return null;
  }
}

export function clearSessionState(): void {
  try {
    localStorage.removeItem(SESSION_STATE_KEY);
  } catch (e) {
    console.error('Failed to clear session state:', e);
  }
}

export function saveSessionToHistory(result: SessionResult): void {
  try {
    const history = getSessionHistory();
    history.unshift(result);
    localStorage.setItem(SESSION_HISTORY_KEY, JSON.stringify(history.slice(0, 20)));
  } catch (e) {
    console.error('Failed to save session to history:', e);
  }
}

export function getSessionHistory(): SessionResult[] {
  try {
    const saved = localStorage.getItem(SESSION_HISTORY_KEY);
    return saved ? JSON.parse(saved) : [];
  } catch (e) {
    console.error('Failed to load session history:', e);
    return [];
  }
}
