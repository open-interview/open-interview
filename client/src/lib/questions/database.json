[
  {
    "id": "db-1",
    "question": "What is the difference between Clustered and Non-Clustered Indexes?",
    "answer": "Clustered Index defines the physical order of data. Non-Clustered is a separate lookup structure.",
    "explanation": "**Clustered Index**:\n- Only 1 per table (usually Primary Key).\n- Leaf nodes contain the ACTUAL data rows.\n- Faster for range queries.\n\n**Non-Clustered Index**:\n- Multiple allowed.\n- Leaf nodes contain pointers to the data (row ID or clustered key).\n- Requires 'Bookmark Lookup' (extra hop) to get full data.",
    "tags": [
      "sql",
      "indexing",
      "perf"
    ],
    "difficulty": "beginner",
    "channel": "database",
    "subChannel": "sql",
    "diagram": "graph TD\n    subgraph Clustered\n    Root1 --> Data[\"Data Pages<br/>Sorted\"]\n    end\n    subgraph NonClustered\n    Root2 --> Ptr[Pointers]\n    Ptr -.-> Data\n    end"
  },
  {
    "id": "db-2",
    "question": "Explain ACID properties in the context of a banking transaction.",
    "answer": "Atomicity, Consistency, Isolation, Durability guarantee valid transactions.",
    "explanation": "**Scenario**: A transfers $100 to B.\n\n- **Atomicity**: All or nothing. If debit A succeeds but credit B fails, ROLLBACK everything.\n- **Consistency**: DB moves from one valid state to another (constraints satisfied, total money same).\n- **Isolation**: Concurrent transactions don't interfere. If C checks A's balance during transfer, they see either pre- or post-state, not intermediate.\n- **Durability**: Once committed, it stays saved even if power fails (Write Ahead Log).",
    "tags": [
      "acid",
      "transactions",
      "theory"
    ],
    "difficulty": "intermediate",
    "channel": "database",
    "subChannel": "transactions",
    "diagram": "\ngraph TD\n    A[Atomicity] --> T[Transaction]\n    C[Consistency] --> T\n    I[Isolation] --> T\n    D[Durability] --> T\n    T --> DB[(Database)]\n"
  },
  {
    "id": "gh-67",
    "question": "What is Database DevOps?",
    "answer": "Database DevOps is the practice of applying DevOps principles to database development and management.",
    "explanation": "Database DevOps is the practice of applying DevOps principles to database development and management.\n\nKey practices:\n1. **Version Control:**\n- Schema versioning\n- Code-first approach\n- Migration scripts\n\n2. **Automation:**\n```yaml\nContinuous Integration:\n- Automated testing\n- Schema validation\n- Data consistency checks\n\nContinuous Delivery:\n- Automated deployments\n- Rollback procedures\n- Data synchronization\n```",
    "tags": [
      "db",
      "devops"
    ],
    "difficulty": "beginner",
    "channel": "database",
    "subChannel": "fundamentals"
  },
  {
    "id": "da-125",
    "question": "Explain database indexing and when to use it.",
    "answer": "Indexes speed up data retrieval at the cost of write performance.",
    "explanation": "**How Indexes Work**:\n- Create a sorted data structure (B-tree, Hash)\n- Points to actual data location\n- Trades write speed for read speed\n\n**When to Use**:\n- Frequently queried columns\n- WHERE clause columns\n- JOIN columns\n- ORDER BY columns\n\n**When NOT to Use**:\n- Small tables\n- Frequently updated columns\n- Low cardinality columns",
    "tags": [
      "sql",
      "indexing"
    ],
    "difficulty": "intermediate",
    "channel": "database",
    "subChannel": "sql",
    "diagram": "graph LR\n    Query --> Index[(Index)]\n    Index --> Data[(Data)]\n    style Index fill:#4ade80"
  }
]