[
  {
    "id": "al-1",
    "question": "When would you use a Linked List over an Array?",
    "answer": "Linked Lists excel at insertions/deletions, Arrays excel at random access.",
    "explanation": "**Array**:\n- Access: O(1) (Direct memory address)\n- Insert/Delete: O(n) (Shift elements)\n- Memory: Contiguous\n\n**Linked List**:\n- Access: O(n) (Traversal)\n- Insert/Delete: O(1) (Change pointer - if you have the node)\n- Memory: Scattered (Heap)\n\n**Use List when**: Implementing Queues, Stacks, or when memory is fragmented.",
    "tags": [
      "struct",
      "comparison",
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "algorithms",
    "subChannel": "data-structures",
    "diagram": "\ngraph LR\n    subgraph Array\n    A1[0] --- A2[1] --- A3[2] --- A4[3]\n    end\n    subgraph LinkedList\n    L1[Node] --> L2[Node] --> L3[Node]\n    end\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-2",
    "question": "Explain QuickSort vs MergeSort. Which is better?",
    "answer": "QuickSort is generally faster in practice (cache locality) but unstable. MergeSort is stable but uses O(n) space.",
    "explanation": "**QuickSort**:\n- Avg: O(n log n), Worst: O(n^2) (bad pivot).\n- Space: O(log n) stack.\n- **In-place**.\n\n**MergeSort**:\n- Always O(n log n).\n- Space: O(n) (aux array).\n- **Stable** (preserves order of equals).\n\n**Verdict**: Arrays -> QuickSort. Linked Lists -> MergeSort.",
    "tags": [
      "sort",
      "recursion",
      "complexity"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "sorting",
    "diagram": "\ngraph TD\n    A[Array] --> P{Pick Pivot}\n    P --> L[Left < Pivot]\n    P --> R[Right > Pivot]\n    L --> Sort1[Recurse]\n    R --> Sort2[Recurse]\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-3",
    "question": "What is Dynamic Programming? How is it different from Recursion?",
    "answer": "DP is Recursion + Optimization (Memoization/Tabulation).",
    "explanation": "Recursion solves subproblems blindly (potentially repeating work).\n\n**DP** stores the result of subproblems so you never solve the same problem twice.\n\n**Example**: Fibonacci.\n- Recursion: `fib(n-1) + fib(n-2)` -> O(2^n)\n- DP: Store `fib` array -> O(n)\n\n**Two Approaches**:\n1. Top-Down (Memoization)\n2. Bottom-Up (Tabulation)",
    "tags": [
      "dp",
      "optimization",
      "theory"
    ],
    "difficulty": "advanced",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "\ngraph TD\n    P[Problem] --> S1[Subproblem 1]\n    P --> S2[Subproblem 2]\n    S1 --> C[(Cache)]\n    S2 --> C\n    C --> R[Result]\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-152",
    "question": "You have a staircase with n steps. You can climb 1, 2, or 3 steps at a time. How many distinct ways can you reach the top? Implement a solution with O(n) time and O(1) space complexity.",
    "answer": "Use DP with 3 variables tracking last 3 positions. dp[i] = dp[i-1] + dp[i-2] + dp[i-3]. Base: dp[0]=1, dp[1]=1, dp[2]=2",
    "explanation": "## Approach\n\nThis is a classic dynamic programming problem similar to climbing stairs, but with three possible steps instead of two.\n\n## Solution\n\n### Recurrence Relation\n\nFor each step `i`, the number of ways to reach it is the sum of ways to reach the previous three steps:\n\n```\ndp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n```\n\n### Base Cases\n\n- `dp[0] = 1` (one way to stay at ground)\n- `dp[1] = 1` (one step)\n- `dp[2] = 2` (1+1 or 2)\n\n### Space Optimization\n\nInstead of maintaining an array of size n, we only need three variables to track the last three positions:\n\n```python\ndef climbStairs(n):\n    if n <= 2:\n        return n if n > 0 else 1\n    \n    a, b, c = 1, 1, 2  # dp[0], dp[1], dp[2]\n    \n    for i in range(3, n + 1):\n        current = a + b + c\n        a, b, c = b, c, current\n    \n    return c\n```\n\n## Complexity\n\n- **Time**: O(n) - single pass through n steps\n- **Space**: O(1) - only three variables used\n\n## Example\n\nFor n=4:\n- dp[3] = dp[2] + dp[1] + dp[0] = 2 + 1 + 1 = 4\n- dp[4] = dp[3] + dp[2] + dp[1] = 4 + 2 + 1 = 7\n\nThere are 7 distinct ways to climb 4 steps.",
    "tags": [
      "dp",
      "optimization"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "graph TD\n    A[\"n=4 (target)\"] --> B[\"n=3 (4 ways)\"]\n    A --> C[\"n=2 (2 ways)\"]\n    A --> D[\"n=1 (1 way)\"]\n    B --> E[\"n=2 (2 ways)\"]\n    B --> F[\"n=1 (1 way)\"]\n    B --> G[\"n=0 (1 way)\"]\n    C --> H[\"n=1 (1 way)\"]\n    C --> I[\"n=0 (1 way)\"]\n    D --> J[\"n=0 (1 way)\"]\n    \n    style A fill:#ff6b6b\n    style B fill:#4ecdc4\n    style C fill:#4ecdc4\n    style D fill:#4ecdc4\n    style E fill:#95e1d3\n    style F fill:#95e1d3\n    style G fill:#95e1d3\n    style H fill:#95e1d3\n    style I fill:#95e1d3\n    style J fill:#95e1d3",
    "lastUpdated": "2025-12-13T01:07:52.426Z"
  }
]