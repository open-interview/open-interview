{
  "question": "Given a directed graph with weighted edges, how would you find the shortest path from a single source to all other vertices using Dijkstra's algorithm?",
  "answer": "Use a priority queue to always expand the vertex with minimum distance, updating distances of adjacent vertices when shorter paths are found.",
  "explanation": "## Why Asked\nTests understanding of greedy algorithms and priority queues in graph traversal, fundamental for network routing and pathfinding problems.\n\n## Key Concepts\n- Greedy algorithm approach\n- Priority queue (min-heap) implementation\n- Distance relaxation technique\n- Time complexity O((V+E)log V)\n- Handles non-negative edge weights only\n\n## Code Example\n```\nfunction dijkstra(graph, start) {\n  const distances = new Map();\n  const pq = new MinPriorityQueue();\n  \n  for (let vertex of graph.keys()) {\n    distances.set(vertex, Infinity);\n  }\n  distances.set(start, 0);\n  pq.enqueue(start, 0);\n  \n  while (!pq.isEmpty()) {\n    const {element: current} = pq.dequeue();\n    \n    for (let [neighbor, weight] of graph.get(current)) {\n      const distance = distances.get(current) + weight;\n      if (distance < distances.get(neighbor)) {\n        distances.set(neighbor, distance);\n        pq.enqueue(neighbor, distance);\n      }\n    }\n  }\n  return distances;\n}\n```\n\n## Follow-up Questions\n- How would you modify this for negative edge weights?\n- What's the difference between Dijkstra and Bellman-Ford?\n- How would you track the actual path, not just distances?\n- Can you implement this using adjacency matrix instead?",
  "diagram": "flowchart TD\n  A[Start] --> B[Initialize distances to âˆž]\n  B --> C[Set source distance to 0]\n  C --> D[Add source to priority queue]\n  D --> E{Queue empty?}\n  E -->|Yes| F[Return distances]\n  E -->|No| G[Extract min distance vertex]\n  G --> H[For each neighbor]\n  H --> I{New distance < current?}\n  I -->|Yes| J[Update distance]\n  I -->|No| K[Skip]\n  J --> L[Add to queue]\n  K --> M{More neighbors?}\n  L --> M\n  M -->|Yes| H\n  M -->|No| E",
  "companies": ["Google", "Amazon", "Meta"],
  "sourceUrl": null,
  "videos": {"shortVideo": null, "longVideo": null}
}